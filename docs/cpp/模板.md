# 模板

模板是创建类或者函数的蓝图或者公式。

## 定义模板

### 函数模板

函数模板是一个公式，用来生成针对特定类型的函数版本。

```cpp
template <typaname T>
int compare(const T &v1, const T &v2) {
  if (v1 < v2) return -1;
  if (v2 < v1) return 1;
  return 0;
}
```

模板定义以关键字 template 开始，后面跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，并用 `<>` 包围起来。

在模板定义中，模板的参数列表不能为空。

使用模板时，需要指定模板实参，将其绑定到模板参数上。调用函数模板时，编译器用函数实参来推断模板实参，称为模板实例化。

模板参数列表分为：

- 模板类型参数：类型说明符，像内置类型或类类型说明符一样。
- 非类型模板参数：一个非类型参数表示一个值而非一个类型。使用特定的类型名，而非 typename 来指定非类型参数。当模板被实例化时，非类型模板参数必须是常量表达式。

函数模板可以声明为 inline 或 constexpr 的，放在模板参数列表之后，返回类型之前。模板程序应尽量减少对实参类型的要求。

当编译器遇到一个函数模板时，并不生成代码，只有当实例化出模板的一个特定版本时，才会生成代码。函数模板和类模板成员函数的定义通常放在头文件中。

### 类模板

类模板用来生成类的蓝图。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型，必须提供额外的类型信息。

类模板定义：

```cpp
template <typename Type> class Queue {};
```

实例化类模板时，需要提供显式模板实参，编译器使用这些模板实参来实例化特定的类。一个类模板中所有的实例都形成一个独立的类。

类模板的成员函数，可定义在类模板的内部或者外部。定义在类模板内部的成员函数隐式成为内联函数。定义在类模板外部时，需要包含模板实参：

```cpp
template <typename T> ret-type Blob::member-name(parm-list)
```

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。如果一个成员函数没有被使用，则它不会被实例化。

在类模板自己的作用域中，可以直接使用类模板名而不提供实参。而在类外部则不行。

当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。类模板与另一个模板间的友好关系的最常见形式是建立对应实例及其友元间的友好关系。

由于模板不是一个类型，所以不能用 typedef 引用一个模板，但可以用 using 为类模板定义类型别名：

```cpp
template<typename T> using twin = pair<T, T>;
```

类模板可以声明 static 成员，所有相同类型的对象，共享相同的静态成员。同样是仅在使用时才实例化成员。

### 模板参数

通常将类型参数命名为 T。

模板参数的作用域与普通的作用域规则相同。模板的声明和定义与普通类和函数定义相同。

当希望通知编译器一个名字表示类型时，必须使用关键字 typename，而不能使用 class。

可以为函数和类模板提供默认实参，只有当它右侧的所有参数有默认实参时，才可以有默认实参。

若类模板使用默认实参，则需要在模板名后跟一个空尖括号对。

### 成员模板

一个类包含本身时模板的成员函数，这种成员称为成员模板，不能是虚函数。该类可以是普通类，或者是类模板。

对于类模板，也可以为其定义成员模板，类和成员可以有各自独立的模板参数。

为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。

### 控制实例化

显示实例化，可避免多个文件中实例化相同模板所带来的额外开销。

一个类模板的实例化定义会实例化该模板的所有成员，包括内联成员函数。所以在类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。

### 效率与灵活性

用户可重载 shared_ptr 的删除器，但 unique_ptr 的删除器只能在定义时以显式模板实参提供。

shared_ptr 在运行时绑定删除器，并且在生命周期中，可以随时改变删除器的类型，比如调用 reset 的时候，可以指定另一种删除器。

unique_ptr 在编译时绑定删除器，即删除器的类型是类类型的一部分，unique_ptr 有两个模板参数，一个是所管理的指针，另一个是删除器的类型。


## 模板实参推断

从函数实参来确定模板实参的过程被称为模板实参推断。在模板实参推断的过程中，编译器使用函数调用中的实参类型来寻找模板实参。

### 类型转换与模板类型参数

对于模板函数，编译器通常为实参生成一个新的模板实例。

在类型转换中，能应用与函数模板的包括：

- const 转换，将一个非 const 对象的引用或指针传递给 const 的引用或指针形参；
- 数组或函数指针转换。数组实参可转换为指向其首元素的指针，函数实参可转换为该函数类型的指针。


## CRTP

> 奇异递归模板模式（curiously recurring template pattern，CRTP），将派生类作为基类的模板参数，实现了静态多态。

传统的动态多态实现中，需要查询虚函数表，降低执行效率。而通过模板实现静态绑定，可兼顾多态实现和效率。

为了在编译时绑定，需要放弃 C++ 的虚函数机制，只是在基类和子类中实现同名函数；同时，为了在编译时确定类型，需要将子类的名字在编译时提前传给基类。因此，要用到 C++ 模板。

```cpp
#include <iostream>

using namespace std;

template<typename T>
class Base {
 public:
    void show() const {
        static_cast<const T*>(this)->show();
    }
};

class Derived: public Base<Derived> {
 public:
    void show() const {
        cout << "Shown in Derived class." << endl;
    }
};

int main() {
    Derived d;
    Base<Derived> *b = &d;
    b->show();
    return 0;
}
```

这是一个简单的 CRTP 例子，有以下特点：

- 基类是一个模板类，接收子类的类型名字；
- 子类的继承列表是 `Derived: public Base<Derived>`；
- 基类函数在函数体中，使用 `static_cast<>` 将基类的指针转换为子类，在编译器完成绑定。
